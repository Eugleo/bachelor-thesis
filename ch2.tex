\chapter{Differential characterisation of disulfide bonds}\label{chap:methods}

\paragraph{Reagents and instrumentation} Trypsin was purchased from Roche, lysosyme and lipase were obtained from Sigma-Aldrich. The used liquid chromatography setup was RSLC nano Ultimate 3000 (Thermo Scientific), for tandem mass spectrometry Orbitrap Fusion Lumos (Thermo Scientific) was employed.

\paragraph{Obtaining the data} We have anaylzed two proteins, lysosyme (LYS) and lipase (LIP). Two samples of each have been obtained in separate sample preparation pathways; in the AT sample preparation pathway, the samples have been alkylated without prior reduction, while in the RAT pathway, reduction took place before the alkylation. In both cases the alkylation has been done by iodacetamide (IAA), resulting in a covalent addition of a carbamidomethyl group (57.07 Da) onto cysteines without DBs; the reduction was achieved by dithiothreitol (DTT). After that, all four samples have been fully digested by trypsine, resulting in two sets of tryptides for each of the two analysed proteins. The samples have been treated the same for the rest of the experiment. After digestion, the peptides had undergone reverse-LC separation that was directly connected to the mass spectrometer through a nanospray ion source. After the measurement of MS\textsuperscript{1} spectra on a quadrupole, the precursors continue on to be fragmented with HCD\@. The MS\textsuperscript{2} spectra were analysed on an orbitrap analyser, as is implied by the use of HCD fragmentation. Finally, raw MS\textsuperscript{2} match data was exported to mgf files. Additionaly an artifical testing dataset based on in-silico digestion and fragmentation of he protein ovalbun has been prepared.

The data have been kindly provided by a IOCB mass specrometry research group (J. Cvačka), and have been measured a few years ago without any direct connection to this thesis.

\section{Dibbi, a program for disulfide bond visualisation}

A Python program termed Dibbi has been developed to analyse the positions of DBs in a protein. The input to Dibbi is the sequence of the analysed protein, and the mgf file with the measured MS\textsuperscript{2} data. It then provides a visualisation of computed scores of each of the possible DBs, and a file with the in-silico generated matches to the individual fragments and precursors, allowing for further manual analysis of the visualised results. Although Dibbi is perfectly able to operate only with the AT sample data, for best results it is preferable to analyse their RAT counterpart first. This enables the user to manually tune the parameters of the subsequent AT analysis, allowing for lower number of false positive hits.

Dibbi first assigns dynamically generated \emph{precursors} to the measured precursor matches, and then assigns in-silico generated fragments from the assigned precursors to the individual peaks in the spectra. Both of the algorithms make use of the divide and conquer~\cite{smith1985design} and branch-and-bound~\cite{boyd2007branch} techniques. Finally, the precurors are scored according to the quality of their fragment matches, among other things, and their score-weighted contributions are added together to form a general overview of the disulfide bonds in the protein. The precursor matching, fragment matching, and scoring algorthms are described in their own sections below.

\subsection{Assigning precursor mass}

At the start, the protein undergoes a complete in-silico digestion, producting basal peptides that can not be digested any further; the protease of our choosing was trypsin, so we call these basal peptides \emph{tryptides}. As mentioned in the first chapter, a protease can sometimes miss a cleavage point, resulting in a peptie chain that is made from two (or more) contiguous basal tryptides connected with a peptide bond. We call a chain of one or more tryptides a \emph{segment}. Finally, due to disulfide bridges crosslinking, a \emph{precursor} is made out of one or more segments connected with interpeptide disulfide bonds.

There can be one or more DB connecting a segment to another segment, and there can also be intrasegment DBs. Cysteines that do not partake in a DB are alkylated, meaning their mass is effectively higher by some configurable constant. In addition, certain amino acid residues are sometimes modified, too, such as the methionine undergoing oxidation. The algorithm treats the latter as optional, or ``variable'' modifications.

From the point of view of this part of the algorithm, it matters not where the individual DBs are located, or which exact methionines are modified, because the individual variations are not distiguishable on the basis of precursor mass. Thus, the precursors in the output of the algorithm only include the information about \textbf{which segments are present}, \textbf{how many DBs there are} --- always at least the number of segments minus 1 --- and how many of each kind of variable modifications there are. This information is passed to the next stage of the program.

Given a target mass to which we want to assign a precursor, the algorithm first chooses a beginning of the first segment. After that the \textsc{FindPrec} function iteratively branches out to search the problem space for precursors that have a theoretical mass within an error boundary around the target mass. The precursor is built segment by segment, and the individual segments are build tryptide by tryptide, both from left to right. In each iteration, the following branching points are tried out:

\begin{enumerate}
	\item Combine the possible modifications and DBs in such a way that the \Var{Selected} segments with the modifications have the correct mass, using the \textsc{Combine} function (see \algref{alg:findprec}{alg:findprec:combinations}). \textsc{Combine} implements a divide-and-conquer algorithm for a modified subset sum problem, in which assignments that are within some error boundary of the target are also considered a valid solution.
	\item Elongate the current segment by adding the current tryptide to it (see \algref{alg:findprec}{alg:findprec:elongate}, and also the whole \Cref{alg:elongate}).
	\item End the current segment (effectively simulating a protease cleavage just before the current tryptide) and begin a new one that begins on the current tryptide or later. See \algref{alg:findprec}{alg:findprec:end}, and the whole \Cref{alg:newseg}.
\end{enumerate}

The fact taht the precursors (and their segments) are built strictly from left to right is a simple form of symmetry breaking --- that is, not generating the multiple equivalent symmetrical solutions. Some further optimizations were added as well, mainly to prevent traversing a branch once we learn it can not provide any more solutions. The used protease is configurable, as well as the amino acid modifications and the maximum number of segments we want the found precursors to have.

% TODO Jak vyadá typický výstup? Co se z něj teda dozvím?

\begin{algorithm}
	\begin{algorithmic}
		\Function{FindPrec}{$I, \mathit{Selected}, \mathit{Mass}, \mathit{Segments}, \mathit{Cys}, \mathit{Open}$}
		\State $\mathit{solutions} \gets$ empty list

		\nb{There is no hanging disulfide bond from previous segments}
		\nb{So let us try to combine residue modifications to find a solution}
		\If{not $\mathit{Open}$}\label{alg:findprec:combinations}
		\State $mods \gets$ calculate possible modifications from $\mathit{Selected}$
		\State $alks \gets$ calculate alkylation count based on seen non-bonded $\mathit{Cys}$
		\State $combinations \gets$ \Call{Combine}{$mass, mods, alks$}
		\State return a list of precursors generated from $combinations$
		\EndIf

		\nb{There are no further solutions, our $\mathit{Mass}$ can not get low enough}
		\If{$\mathit{Mass}$ is too high, or $i$ is at the end}
		\State return empty list
		\EndIf

		\nb{End this segment, connect next one with a disulfide bond}
		\nb{That is, if we have the segments budget and a free cysteine}
		\If{not $\mathit{Open}$, and $\mathit{Segments} > 0$, and $\mathit{Cys} > 0$}\label{alg:findprec:end}
		\State $S \gets$ \Call{NewSegment}{$I, \mathit{Selected}, \mathit{Mass}, \mathit{Segments}, \mathit{Cys}, \mathit{Open}$}
		\State concatenate $\mathit{solutions}$ with the list $S$
		\EndIf

		\nb{Elongate the current segment by one tryptide}
		\State $S \gets$ \Call{Elongate}{$I, \mathit{Selected}, \mathit{Mass}, \mathit{Segments}, \mathit{Cys}, \mathit{Open}$}\label{alg:findprec:elongate}
		\State concatenate $\mathit{solutions}$ with the list $S$
		\State return the list $\mathit{solutions}$

		\EndFunction
	\end{algorithmic}
	\caption{The main part of the precursor matching algorithm, in which all the braching occurs.}\label{alg:findprec}
\end{algorithm}


\begin{algorithm}
	\begin{algorithmic}
		\Function{Elongate}{$I, Selected, \mathit{Mass}, \mathit{Segments}, \mathit{Cys}, \mathit{Open}$}
		\nb{Prolong the current segment by one tryptide}

		\State $\mathit{tryptide} \gets$ the $I$-th tryptide from the list $\mathit{TRYPTIDES}$
		\State $\mathit{mass'} \gets$ the mass of $\mathit{tryptide}$ added to $\mathit{Mass}$
		\State $\mathit{cys'}\gets$ the number of cys in $\mathit{tryptide}$ added to $\mathit{Cys}$
		\Decl{cys'}{lower \Var{cys'} by one if \Var{Open} is true, using a cys to close the bond}
		\State $\mathit{open'} \gets$ False if this tryptide had any cysteines, otherwise $\mathit{Open}$

		\nb{Call the original function}
		\State $S \gets$ \Call{FindPrec}{$I + 1, \mathit{Selected}, \mathit{mass'}, \mathit{Segments}, cys', \mathit{open'}$}
		\State return the list $S$

		\EndFunction
	\end{algorithmic}
	\caption{Elongates the currently built precursor segment, adding the current tryptide to it.}\label{alg:elongate}
\end{algorithm}


\begin{algorithm}
	\begin{algorithmic}
		\Function{NewSegment}{$I, \mathit{Selected}, \mathit{Mass}, \mathit{Segments}, \mathit{Cys}, \mathit{Open}$}
		\State $sel' \gets$ the currently ending segment added to $\mathit{Selected}$
		\State $\mathit{mass'} \gets$ subtract mass of $\ce{H2}$ from $\mathit{Mass}$, due to the new DB
		\nb{Update the budget, because of the newly started segment}
		\State $\mathit{seg'} \gets \mathit{Segments} - 1$
		\nb{Begin the bond with one of our cysteines}
		\State $\mathit{cys'}\gets \mathit{Cys} - 1$
		\nb{The new bond is waiting to get ``closed'' by a cys in the next run}
		\State $\mathit{open'} \gets$ True

		\nb{Finally, branch out: start a new segment from all possible starting points}
		\For{all possible beginings of the next segment from $I + 1$ onward}
		\State $i' \gets$ the next beginning
		\State $S \gets$ \Call{FindPrec}{$\mathit{i'}, \mathit{selected'}, \mathit{mass'}, \mathit{segments'}, \mathit{cys'}, \mathit{open'}$}
		\State return the list $S$
		\EndFor

		\EndFunction
	\end{algorithmic}
	\caption{Ends the currently built precursor segment and begins a new one, beginning with the current tryptide, or any tryptide coming after it.}\label{alg:newseg}
\end{algorithm}


\subsection{Assigning fragment mass}

Our task now is to assign in-silico generated precursor fragments to the peaks from the spectra. The quality of these assignments will later be used to score the precursor matches and ultimately to find out some information about the position of DBs in the protein.

Before the main of this stage of the program, there is an in-between processing step that takes a precursor from the precursor-matching stage, and generates all possible \emph{variants} it could represent. A \emph{variant} is a set of segments with precisely defined DB crosslinks --- that differentiates it from a precursor (which is the output of the previous stage), as precursor only holds information about the number of DBs, but not their positions.

Similarly to how precursors are constructed from crosslinked segments, and the segments from basal tryptides, fragments can also be broken down to smaller pieces; we call them \emph{cuts}. A \emph{cut} is a part of a precursor segment; it never spanns more than one segment. All of the fragment cuts form a connected subgraph in the variant graph.

A rough outline of the algorithm can be seen in \Cref{alg:fragment}. At the start, a beginning is chosen for the first cut of the fragment. In further iterations of the main function, the algorithm branches out. Before we describe the braching, we have to explain the notion of \emph{pivots}. Imagine the algorithm is building a cut, residue by residue, and it encouters a cysteine connected with a DB to another segment in the variant. When the algorihm makes the decision to keep the bond intact, the other cysteine surely will have to be in the final fragment, possibly with some other neighbouring residues from its segment. The cysteine is thus added to the list of \emph{pivots}, and when the current cut is ended, the algorithm jumps to the next pivot from the list and builds a new cut around them.

In this way, the algorithm can jump back and forth between segments, following the directions of DBs in the variant, building cuts around cysteines, until it runs out of pivots, runs out of residues in the variant, or until its mass is too high. The algorithm keeps track of all residues that are part of the current fragment, in order not to add any residue twice by adding cuts with nonempty intersection. Furthermore, the number of peptide bond and disulfide bond breaks is bounded, usually to be at most 1 or 2.

In each iteration, the algorithm attempts to do all of the following:

\begin{enumerate}
	\item Try to combine the masses of the selected cuts and some of the variable modifications to obtain a fragment with a mass that is within the error boundary around the target mass. In case of a success, add this fragment (that is, this combination of cuts and modifications) to a list of solutions.
	\item If the current residue is a cysteine partaking in a DB that we have not seen yet, branch out. Break the bond in one branch, adding assymetric modifications to both of the cysteines, and keep the bond intact in the other, adding a new \emph{pivot} to the list of pivots.
	\item Elongate the current cut by adding the next residue to it. The ``next residue'' is simply the next residue in the segment from which the cut is made. If there is no ``next residue'' in this segment, end this cut, and jump to the next pivot. If there is no pivot to jump to, end this branch of the algorithm.
	\item End this cut prematurely (in the middle of a segment), that is, simulate a peptide bond dissociation in the precursor. Jump to the next pivot, if there is any, or end this branch of the algorithm.
\end{enumerate}


\begin{algorithm}
	\begin{algorithmic}
		\Function{FragFind}{$I, \mathit{BreaksLeft}, \mathit{ValidEndRange}, \mathit{Mass}, \mathit{Pivots}$}

		\Decl{solutions}{an empty list}

		\Decl{can end}{the end would not be premature, or \Var{BreaksLeft} $> 0$}
		\If{\Var{I} is in \Var{ValidEndRange}, and also \Var{can end}}

		\If{can \textsc{Combine} the cuts with some mods to match \Var{TARGET}}
		\Decl{solutions}{the current \Var{solutions} with any of the new ones added}
		\EndIf

		\If{there is some pivot $\mathit{p}$ in $\mathit{Pivots}$}
		\Decl{startrange, endrange}{the valid cut range around \Var{p}}
		\Decl{pivots'}{\Var{pivots} with the pivot \Var{p} removed}
		\Decl{breaks'}{\Var{BreaksLeft}, possibly one less if the end is premature}
		\For{every valid cut start in \Var{startrange}}
		\Decl{S}{\Call{FragFind}{$\mathit{start}, \mathit{breaks'}, \mathit{endrange}, \mathit{Mass}, \mathit{pivots}$}}
		\Decl{solutions}{the current \Var{solutions} concatenated to \Var{S}}
		\EndFor
		\EndIf

		\EndIf

		\If{the \Var{I}-th residue is a cys partaking in a DB we have not seen yet}

		\nb{Break the bond...}
		\If{we have some breaks to spare}
		\State add the current cysteine to the broken bond counter, then...
		\Decl{mass'}{the current \Var{Mass} added to the mass of the \Var{I}-th residue}
		\Decl{S}{\Call{FragFind}{$I + 1, \mathit{BreaksLeft} - 1, \mathit{ValidCutRange}, \mathit{mass'}, \mathit{pivots}$}}
		\Decl{solutions}{the current \Var{solutions} concatenated to \Var{S}}
		\EndIf
		\nb{...or keep it intact}
		\Decl{pivots'}{add the other end of the bond to \Var{Pivots}}
		\Decl{mass'}{the mass of the bond, $\ce{H2}$, subtracted from \Var{Mass}}
		\Decl{S}{\Call{FragFind}{$I + 1, \mathit{BreaksLeft}, \mathit{ValidCutRange}, \mathit{mass'}, \mathit{pivots'}$}}

		\Decl{solutions}{the current \Var{solutions} concatenated to \Var{S}}

		\Else
		\nb{Continue adding to this cut}
		\Decl{mass'}{the current \Var{Mass} added to the mass of the \Var{I}-th residue}
		\Decl{S}{\Call{FragFind}{$I + 1, \mathit{BreaksLeft}, \mathit{ValidCutRange}, \mathit{mass'}, \mathit{pivots}$}}
		\Decl{solutions}{the current \Var{solutions} concatenated to \Var{S}}
		\EndIf
		\State return the list \Var{solutions}
		\EndFunction
	\end{algorithmic}
	\caption{A very high-level overview of the basic functionality of the fragment matching algotihm.}\label{alg:fragment}
\end{algorithm}

\section{Precursor scoring and result visualisation}

Initially the idnvidiual precursor assignemnts from the first stage are scored, then the fragment assginments from the second stage, and the two scores are put together to score the variants (precursors with concrete bond configurations). After that, we treat each variant as evidence confirming its spefcific DB configuration, and we add the individual pieces of evidence from every variant together, each evidence weighted by the score of its parent variant. We treat evidence abuout alkylation in the same way. Finally, we visualise the collected evidence.

\paragraph{Precursor scoring} The score for a precursor \(P\) is computed as \[\operatorname{score}(P) = \frac{1}{1 + (\mathit{variants}_P, \mathit{mc}_P, \mathit{mass}_P, \mathit{error}_P)\bm{w_P}},\] where \(\bm{w_P}\) is a vector of weights, \(\mathit{variants}\) is the number of different variants that can be generated from \(P\), \(\mathit{mc}\) is the maximum number of missed cleavages among its segments, \(\mathit{mass}\) is its mass, and \(\mathit{error}\) is the ppm error of the assignment. All of the attributes of \(P\) are normalised before the score is computed. In this thesis we set \(\bm{w_P} = (32, 4, 4, 4)^T\).

\paragraph{Fragment scoring} The score for a fragment \(F\) is computed as \[\operatorname{score}(F) = \frac{1}{1 + (\mathit{charge}_F, \mathit{mods}_F, \mathit{error}_F)\bm{w_F}},\] where \(\bm{w_F}\) is a vector of weights, \(\mathit{charge}\) is the charge of the fragment, \(\mathit{mods}\) is the total number of its mods (including neutral losses), and \(\mathit{error}\) is the ppm error of the assignment. All of the attributes of \(F\) are normalised before the score is computed. In this thesis we set \(\bm{w_F} = (16, 4, 4)^T\). The weights were set according to our expectations based on the biological and informatical background of the problem, as well as according to the patterns in the data.

\paragraph{Variant scoring} The score of a variant \(V\) is computed as \[\operatorname{score}(V) = \operatorname{score}(\mathit{precursor}_P) + w_f \cdot \operatorname{median}(\{ \operatorname{score}(F), F \in \mathit{fragments}_V \}).\] In this thesis we use \(w_f = 1/2\).

\paragraph{Score aggregation} For every theoretically possible disulfide bond \(B = (u, v)\) the following evidence score is computed  from the assigned fragments, \[\operatorname{score}(B) = \sum_{\text{assigned fragment } F} \operatorname{score}(\mathit{variant}_F) \cdot [B \in \mathit{bonds}_F], \] where \(\mathit{bonds}\) is a set of DBs that are present in the fragment. Similary for every cysteine \(C\) an alkylation score is computed, \[\operatorname{score}(C) = \sum_{\text{assigned fragment } F} \operatorname{score}(\mathit{variant}_F) \cdot [C \in \mathit{alkcys}_F],\] where \(\mathit{alkcys}\) is a set of alkylated cysteines that are present in the fragment.

% TODO Přidat odkaz na vizualizaci v další kapitole

\paragraph{Visualisation} The aggregated evidence is plotted independenlty for each disulfide bond and --- in the case of alkylation --- for each cysteine. The evidence for a bond \(B = (u, v)\) is visualised separately in each direction, \((u, v)\) and \((v, u)\). The evidence for bond \((u, v)\) in that specific direction is normalised in the context of every other bond \(u, X\), and the evidence for alkylation of the \(u\) cysteine. No further automatic interpretation is done, to keep the plots as close to the raw assignment data as possible. Along with a plot of the aAT sample for the protein, there is also a plot for the prediction of bonds in the RAT sample --- in this way, the researcher can deduce which parts of the given protein are prone to generating false positives, and can adjust the weights for scoring the AT sample accordingly.In addition to those two plots, plots of ``gold'' data are shown, representing the theoretical true state of the analysed protein.

In both the fragment and the precursor scoring, the numerators can be dynamically adjusted based on what bond is the algorithm scoring. The users are encouraged to perform a differential analysis by first runnning the program as-is, and then adjusting for false-positive-prone cysteine bonds by lowering the weights of the bonds that the algorithm (falsely) identified in the RAT sample.


% \section{Example with some mathematics}
% \label{sec:demo}

% \begin{defn}[Triplet]\label{defn:x}
% Given stuff $X$, $Y$ and $Z$, we will write a \emph{triplet} of the stuff as $(X,Y,Z)$.
% \end{defn}

% \newcommand{\Col}{\textsc{Colour}}

% \begin{thm}[Car coloring]\label{thm:y}
% All cars have the same color. More specifically, for any set of cars $C$, we have
% $$(\forall c_1, c_2 \in C)\:\Col(c_1) = \Col(c_2).$$
% \end{thm}

% \begin{proof}
% Use induction on sets of cars $C$. The statement holds trivially for $|C|\leq1$. For larger $C$, select 2 overlapping subsets of $C$ smaller than $|C|$ (thus same-colored). Overlapping cars need to have the same color as the cars outside the overlap, thus also the whole $C$ is same-colored.\todo{This is plain wrong though.}
% \end{proof}

% \begin{table}
% \centering
% {\footnotesize\sf
% \begin{tabular}{llrl}
% \toprule
% Column A & Column 2 & Numbers & More \\
% \midrule
% Asd & QWERTY & 123123 & -- \\
% Asd qsd 1sd & \textcolor{red}{BAD} & 234234234 & This line should be helpful. \\
% Asd & \textcolor{blue}{INTERESTING} & 123123123 & -- \\
% Asd qsd 1sd & \textcolor{violet!50}{PLAIN WEIRD} & 234234234 & -- \\
% Asd & QWERTY & 123123 & -- \\
% \addlinespace % a nice non-intrusive separator of data groups (or final table sums)
% Asd qsd 1sd & \textcolor{green!80!black}{GOOD} & 234234299 & -- \\
% Asd & NUMBER & \textbf{123123} & -- \\
% Asd qsd 1sd & DIFFERENT & 234234234 & (no data) \\
% \bottomrule
% \end{tabular}}
% \caption{An example table. Table caption should clearly explain how to interpret the data in the table. Use some visual guide, such as boldface or color coding, to highlight the most important results (e.g., comparison winners).}
% \label{tab:z}
% \end{table}

% \begin{figure}
% \centering
% \includegraphics[width=.6\linewidth]{img/ukazka-obr02.pdf}
% \caption{A figure with a plot, not entirely related to anything. If you copy the figures from anywhere, always refer to the original author, ideally by citation (if possible). In particular, this picture --- and many others, also a lot of surrounding code --- was taken from the example bachelor thesis of MFF, originally created by Martin Mareš and others.}
% \label{fig:g}
% \end{figure}

% \begin{figure}
% \centering
% \tikzstyle{box}=[rectangle,draw,rounded corners=0.5ex,fill=green!10]
% \begin{tikzpicture}[thick,font=\sf\scriptsize]
% \node[box,rotate=45] (a) {A test.};
% \node[] (b) at (4,0) {Node with no border!};
% \node[circle,draw,dashed,fill=yellow!20, text width=6em, align=center] (c) at (0,4) {Ugly yellow node.\\Is this the Sun?};
% \node[box, right=1cm of c] (d) {Math: $X=\sqrt{\frac{y}{z}}$};
% \draw[->](a) to (b);
% \draw[->](a) to[bend left=30] node[midway,sloped,anchor=north] {flow flows} (c);
% \draw[->>>,dotted](b) to[bend right=30] (d);
% \draw[ultra thick](c) to (d);

% \end{tikzpicture}
% \caption{An example diagram typeset with TikZ.}
% \label{fig:schema}

% % \begin{algorithm}
% % \begin{algorithmic}
% % \Function{ExecuteWithHighProbability}{$A$}
% % 	\State $r \gets$ a random number between $0$ and $1$
% % 	\State $\varepsilon \gets 0.0000000000000000000000000000000000000042$
% % 	\If{$r\geq\varepsilon$}
% % 		\State execute $A$ \Comment{We discard the return value}
% % 	\Else
% % 		\State print: \texttt{Not today, sorry.}
% % 	\EndIf
% % \EndFunction
% % \end{algorithmic}
% % \caption{Algorithm that executes an action with high probability. Do not care about formal semantics in the pseudocode --- semicolons, types, correct function call parameters and similar nonsense from `realistic' languages can be safely omitted. Instead make sure that the intuition behind (and perhaps some hints about its correctness or various corner cases) can be seen as easily as possible.}
% % \label{alg:w}
% % \end{algorithm}

% \section{Extra typesetting hints}

% Do not overuse text formatting for highlighting various more or less parts of your sentences; if an idea cannot be communicated without formatting, the sentence probably needs rewriting anyway.

% Most importantly, do \underline{not} overuse bold text, which is designed to literally \textbf{shine from the page} to be the first thing that catches the eye of the reader. More precisely, use bold text only for `navigation' elements that need to be seen first, such as headings, list item names, and figure numbers.

% Use underline only in dire necessity, such as in the previous paragraph where it was inevitable to ensure that the reader remembers to never typeset boldface text manually again.

% Use \emph{emphasis} to highlight the first occurrences of important terms that the reader should notice. The feeling the emphasis produces is, roughly, ``Oh my --- what a nicely slanted word! Surely I expect it be important for the rest of the thesis!''

% Finally, never draw a vertical line (e.g., in a table or around figures), ever. Vertical lines outside of the figures are ugly.


% \chapter{More complicated chapter}
% \label{chap:math}

% After the reader gained sufficient knowledge to understand your problem in \cref{chap:refs}, you can jump to your own advanced material and conclusions.

% You will need definitions (see \cref{defn:x} below in \cref{sec:demo}), theorems (\cref{thm:y}), general mathematics, algorithms (\cref{alg:w}), and tables (\cref{tab:z})\todo{See documentation of package \texttt{booktabs} for hints on typesetting tables. As a main rule, \emph{never} draw a vertical line.}. \Cref{fig:f,fig:g} show how to make a nice figure. See \cref{fig:schema} for an example of TikZ-based diagram. Cross-referencing helps a lot to keep the necessary parts of the narrative close --- use references to the previous chapter with theory wherever it seems that the reader could have forgotten the required context.

% \section{Example with some mathematics}
% \label{sec:demo}

% \begin{defn}[Triplet]\label{defn:x}
% Given stuff $X$, $Y$ and $Z$, we will write a \emph{triplet} of the stuff as $(X,Y,Z)$.
% \end{defn}

% \newcommand{\Col}{\textsc{Colour}}

% \begin{thm}[Car coloring]\label{thm:y}
% All cars have the same color. More specifically, for any set of cars $C$, we have
% $$(\forall c_1, c_2 \in C)\:\Col(c_1) = \Col(c_2).$$
% \end{thm}

% \begin{proof}
% Use induction on sets of cars $C$. The statement holds trivially for $|C|\leq1$. For larger $C$, select 2 overlapping subsets of $C$ smaller than $|C|$ (thus same-colored). Overlapping cars need to have the same color as the cars outside the overlap, thus also the whole $C$ is same-colored.\todo{This is plain wrong though.}
% \end{proof}

% \begin{table}
% % uncomment the following line if you use the fitted top captions for tables
% % (see the \floatsetup[table] comments in `macros.tex`.
% %\floatbox{table}[\FBwidth]{
% \centering\footnotesize\sf
% \begin{tabular}{llrl}
% \toprule
% Column A & Column 2 & Numbers & More \\
% \midrule
% Asd & QWERTY & 123123 & -- \\
% Asd qsd 1sd & \textcolor{red}{BAD} & 234234234 & This line should be helpful. \\
% Asd & \textcolor{blue}{INTERESTING} & 123123123 & -- \\
% Asd qsd 1sd & \textcolor{violet!50}{PLAIN WEIRD} & 234234234 & -- \\
% Asd & QWERTY & 123123 & -- \\
% \addlinespace % a nice non-intrusive separator of data groups (or final table sums)
% Asd qsd 1sd & \textcolor{green!80!black}{GOOD} & 234234299 & -- \\
% Asd & NUMBER & \textbf{123123} & -- \\
% Asd qsd 1sd & DIFFERENT & 234234234 & (no data) \\
% \bottomrule
% \end{tabular}
% %}{  % uncomment if you use the \floatbox (as above), erase otherwise
% \caption{An example table.  Table caption should clearly explain how to interpret the data in the table. Use some visual guide, such as boldface or color coding, to highlight the most important results (e.g., comparison winners).}
% %}  % uncomment if you use the \floatbox
% \label{tab:z}
% \end{table}

% \begin{figure}
% \centering
% \includegraphics[width=.6\linewidth]{img/ukazka-obr02.pdf}
% \caption{A figure with a plot, not entirely related to anything. If you copy the figures from anywhere, always refer to the original author, ideally by citation (if possible). In particular, this picture --- and many others, also a lot of surrounding code --- was taken from the example bachelor thesis of MFF, originally created by Martin Mareš and others.}
% \label{fig:g}
% \end{figure}

% \begin{figure}
% \centering
% \tikzstyle{box}=[rectangle,draw,rounded corners=0.5ex,fill=green!10]
% \begin{tikzpicture}[thick,font=\sf\scriptsize]
% \node[box,rotate=45] (a) {A test.};
% \node[] (b) at (4,0) {Node with no border!};
% \node[circle,draw,dashed,fill=yellow!20, text width=6em, align=center] (c) at (0,4) {Ugly yellow node.\\Is this the Sun?};
% \node[box, right=1cm of c] (d) {Math: $X=\sqrt{\frac{y}{z}}$};
% \draw[->](a) to (b);
% \draw[->](a) to[bend left=30] node[midway,sloped,anchor=north] {flow flows} (c);
% \draw[->>>,dotted](b) to[bend right=30] (d);
% \draw[ultra thick](c) to (d);

% \end{tikzpicture}
% \caption{An example diagram typeset with TikZ.}
% \label{fig:schema}
% \end{figure}

% \begin{algorithm}
% \begin{algorithmic}
% \Function{ExecuteWithHighProbability}{$A$}
% 	\State $r \gets$ a random number between $0$ and $1$
% 	\State $\varepsilon \gets 0.0000000000000000000000000000000000000042$
% 	\If{$r\geq\varepsilon$}
% 		\State execute $A$ \Comment{We discard the return value}
% 	\Else
% 		\State print: \texttt{Not today, sorry.}
% 	\EndIf
% \EndFunction
% \end{algorithmic}
% \caption{Algorithm that executes an action with high probability. Do not care about formal semantics in the pseudocode --- semicolons, types, correct function call parameters and similar nonsense from `realistic' languages can be safely omitted. Instead make sure that the intuition behind (and perhaps some hints about its correctness or various corner cases) can be seen as easily as possible.}
% \label{alg:w}
% \end{algorithm}

% \section{Extra typesetting hints}

% Do not overuse text formatting for highlighting various important parts of your sentences. If an idea cannot be communicated without formatting, the sentence probably needs rewriting anyway. Imagine the thesis being read aloud as a podcast --- the storytellers are generally unable to speak in boldface font.

% Most importantly, do \underline{not} overuse bold text, which is designed to literally \textbf{shine from the page} to be the first thing that catches the eye of the reader. More precisely, use bold text only for `navigation' elements that need to be seen and located first, such as headings, list item leads, and figure numbers.

% Use underline only in dire necessity, such as in the previous paragraph where it was inevitable to ensure that the reader remembers to never typeset boldface text manually again.

% Use \emph{emphasis} to highlight the first occurrences of important terms that the reader should notice. The feeling the emphasis produces is, roughly, ``Oh my --- what a nicely slanted word! Surely I expect it be important for the rest of the thesis!''

% Finally, never draw a vertical line, not even in a table or around figures, ever. Vertical lines outside of the figures are ugly.
